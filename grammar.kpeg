%% { attr_accessor :ast }

%% {
  def initialize(*args)
    super

    @precedence = {
      "*" => 8,
      "/" => 8,
      "+" => 7,
      "-" => 7,
      "==" => 10,
      ":=" => 0,
      "&&" => 3,
      "||" => 2
    }

    @assoc = {
      ":=" => :right,
      "<<" => :left
    }
  end

  def set_assoc(operator, assoc)
    @assoc[operator] = assoc
  end

  def prec(op)
    if level = @precedence[op]
      return level
    end

    return 5
  end

  def assoc(op)
    @assoc[op]
  end

  def binary(o, l, r)
    Talon::AST::BinaryOperator.new(l, r, o)
  end

  # courtesy of alexsuraci (@vito on github and twitter)
  #
  # when resolving `1 + 2 * 3', the call path is:
  #
  #     resolve(nil, 1, [+, 2, *, 3])
  #     | resolve(+, 2, [*, 3])
  #     | | resolve(*, 3, [])
  #     | | `-> [3, []]
  #     | `-> resolve(+, binary(*, 2, 3), [])
  #     |     `-> [(2 * 3), []]
  #     `-> resolve(nil, binary(+, 1, (2 * 3)), [])
  #         `-> [(1 + (2 * 3)), [])
  #
  # where `binary(+, y, z)' constructs `y + z', with
  # `z' being the expression from the nested resolve
  #
  def resolve(a, e, chain)
    # if the chain is empty, we've got a full expression
    # this is guaranteed to occur because we start with `a' as `nil',
    # which means it'll keep resolving until the chain is consumed.
    return [e, []] if chain.empty?

    # pull the next operator out of the chain
    b, *rest = chain

    # if `a' is non-nil, and `a' and `b' associate to the left,
    # stop, returning the expression and the rest of the chain,
    # which will get picked up again when building up `a'
    if a && (prec(a) > prec(b) || (prec(a) == prec(b) && assoc(a) == :left))
      [e, chain]
    else
      # pull the next expression out to resolve the next operator
      e2, *rest2 = rest

      # resolve from the next operator onward,
      # capturing the unconsumed bits as rest3
      r, rest3 = resolve(b, e2, rest2)

      # continue with the remaining chain (rest3)
      # note that the original arg is passed here,
      # with the next one already done
      resolve(a, binary(b, e, r), rest3)
    end
  end
}

eof = !.

space = " " | "\t"

nl = "\n"

sp = space+
- = space* 

br-sp = (space | nl)*

expr_end = ("\n" | ";") br-sp

number = < /[1-9][0-9]*/ > { text }

integer = number:n { Talon::AST::Number.new(n.to_i) }
float = number:w "." number:f { Talon::AST::Number.new("#{w}.#{f}".to_f) }

true = "true" { Talon::AST::True.new }
false = "false" { Talon::AST::False.new }

keyword = "end" | "else"

word = !keyword < /[a-zA-Z_][a-zA-Z0-9_]*/ > { text }

identifier = word:w { Talon::AST::Identifier.new(w) }

many_expr = expr:e expr_end many_expr:m { [e] + m }
          | expr:e { [e] }

sequence = many_expr:e
           { e.size > 1 ? Talon::AST::Sequence.new(e) : e.first }

expr_list_b = expr:e br-sp "," br-sp expr_list_b:l { [e] + l }
            | expr:e { [e] }

expr_list = br-sp expr_list_b:b br-sp { b }

if = "if" sp expr:c expr_end sequence:t expr_end "end"
     { Talon::AST::If.new(c,t,nil) }
   | "if" sp expr:c expr_end expr:t expr_end "else" expr_end expr:f expr_end "end"
     { Talon::AST::If.new(c,t,f) }

typed_ident = word:i ":" word:t
            { Talon::AST::TypedIdentifier.new(i,t) }
            | identifier

ident_list = typed_ident:i br-sp "," br-sp ident_list:l { [i] + l }
           | typed_ident:i { [i] }

def_args = "(" br-sp ident_list:l br-sp ")" { l }

ret_type = - ":" - word:t { t }

templated_name = word:w "[" expr_list:e "]"
                 { Talon::AST::TemplatedName.new(w,e) }
               | word:w

def_start = "def" sp templated_name:w { w }

def = def_start:w def_args?:a ret_type?:t expr_end "end"
      { Talon::AST::MethodDefinition.new(w,a,nil,t) }
    | def_start:w def_args?:a ret_type?:t expr_end sequence:s expr_end "end"
      { Talon::AST::MethodDefinition.new(w,a,s,t) }

class_start = "class" sp templated_name:w { w }
class_superclass = - "<" - templated_name:s { s }

class = class_start:w class_superclass?:s expr_end "end"
        { Talon::AST::ClassDefinition.new(w,s,nil) }
      | class_start:w class_superclass?:s expr_end sequence:e expr_end "end"
        { Talon::AST::ClassDefinition.new(w,s,e) }

operator_chars = /[~`!@#$\%^\&*\\+\-\/?:<=>\|]/
unary_operator = < operator_chars > { text }
binary_operator = < operator_chars+ > { text }

literal = float
        | integer
        | true
        | false
        | identifier

embed_rhs = literal:r "." word:w
            { Talon::AST::MethodCall.new(r,w,nil) }
          | literal

call_np_list = method_np_arg:e - "," - call_np_list:l { [e] + l }
             | method_np_arg:e { [e] }

method_call_np = method_np_recv:r "." word:w sp call_np_list:l
                 { Talon::AST::MethodCall.new(r,w,l) }

method_np_recv = method_np_recv:r "." word:w "(" expr_list:l ")"
                 { Talon::AST::MethodCall.new(r,w,l) }
               | method_np_recv:r "[" expr_list:l "]"
                 { Talon::AST::BracketOperator.new(r,l) }
               | literal

method_np_arg = grouped
              | binary_send
              | method_np_arg:r "." word:w "(" expr_list?:l ")"
                { Talon::AST::MethodCall.new(r,w,l) }
              | method_np_arg:r "." word:w
                { Talon::AST::MethodCall.new(r,w,nil) }
              | method_np_arg:r "[" expr_list:l "]"
                { Talon::AST::BracketOperator.new(r,l) }
              | literal

method_call = method_call:r "." word:w "(" expr_list?:l ")"
              { Talon::AST::MethodCall.new(r,w,l) }
            | method_call:r "." word:w
              { Talon::AST::MethodCall.new(r,w,nil) }
            | method_call:r "[" expr_list:l "]"
              { Talon::AST::BracketOperator.new(r,l) }
            | literal

bin_expr = bin_expr:r "." word:w "(" expr_list?:l ")"
            { Talon::AST::MethodCall.new(r,w,l) }
          | bin_expr:r "." word:w
            { Talon::AST::MethodCall.new(r,w,nil) }
          | literal

binary_c = (- binary_operator:o - bin_expr:e { [o, e] })+:bs { bs.flatten }
binary_send = bin_expr:l binary_c:c { resolve(nil, l, c).first }

call = unary_operator:o expr:r
       { Talon::AST::UnaryOperator.new(r,o) }
     | binary_send
     | method_call_np
     | method_call

expr = if
     | def
     | class
     | call

grouped = "(" expr:e ")"
          { Talon::AST::Grouped.new(e) }

root = sequence:e eof { @ast = e }
