%% { attr_accessor :ast }

%% {
  def initialize(*args)
    super

    @precedence = {
      "*" => 8,
      "/" => 8,
      "+" => 7,
      "-" => 7,
      "==" => 10,
      ":=" => 0,
      "&&" => 3,
      "||" => 2
    }

    @assoc = {
      ":=" => :right,
      "<<" => :left
    }
  end

  def set_assoc(operator, assoc)
    @assoc[operator] = assoc
  end

  def prec(op)
    if level = @precedence[op]
      return level
    end

    return 5
  end

  def assoc(op)
    @assoc[op]
  end

  # courtesy of alexsuraci (@vito on github and twitter)
  #
  # when resolving `1 + 2 * 3', the call path is:
  #
  #     resolve(nil, 1, [+, 2, *, 3])
  #     | resolve(+, 2, [*, 3])
  #     | | resolve(*, 3, [])
  #     | | `-> [3, []]
  #     | `-> resolve(+, binary(2, 3, *), [])
  #     |     `-> [(2 * 3), []]
  #     `-> resolve(nil, binary(1, (2 * 3), +), [])
  #         `-> [(1 + (2 * 3)), [])
  #
  # where `binary(y, z, +)' constructs `y + z', with
  # `z' being the expression from the nested resolve
  #
  def resolve(a, e, chain)
    # if the chain is empty, we've got a full expression
    # this is guaranteed to occur because we start with `a' as `nil',
    # which means it'll keep resolving until the chain is consumed.
    return [e, []] if chain.empty?

    # pull the next operator out of the chain
    b, *rest = chain

    # if `a' is non-nil, and `a' and `b' associate to the left,
    # stop, returning the expression and the rest of the chain,
    # which will get picked up again when building up `a'
    if a && (prec(a) > prec(b) || (prec(a) == prec(b) && assoc(a) == :left))
      [e, chain]
    else
      # pull the next expression out to resolve the next operator
      e2, *rest2 = rest

      # resolve from the next operator onward,
      # capturing the unconsumed bits as rest3
      r, rest3 = resolve(b, e2, rest2)

      # continue with the remaining chain (rest3)
      # note that the original arg is passed here,
      # with the next one already done
      resolve(a, binary(e, r, b), rest3)
    end
  end
}

%% ast-location = ::Talon::AST
%% comment = ast Comment(text)
%% bracket = ast BracketOperator(receiver, arguments)
%% number = ast Number(value)
%% bool_true = ast True()
%% bool_false = ast False()
%% ident = ast Identifier(name)
%% typed_ident = ast TypedIdentifier(name, type)
%% templated_name = ast TemplatedName(name, arguments)
%% method_def = ast MethodDefinition(name, arguments, body, return_type)
%% class_def = ast ClassDefinition(name, superclass_name, body)
%% seq = ast Sequence(elements)
%% if_node = ast If(condition, then_body, else_body)
%% call = ast MethodCall(receiver, method_name, arguments)
%% unary = ast UnaryOperator(receiver, operator)
%% binary = ast BinaryOperator(receiver, argument, operator)
%% group = ast Grouped(expression)

eof = !.

space = " " | "\t"

nl = "\n"

sp = space+
- = space* 

comment = "--" < (!nl .)* > nl ~comment(text)

br-sp = (space | nl)*

expr_end = ("\n" | ";") br-sp

number = < /[1-9][0-9]*/ > { text }

integer = number:n ~number(n.to_i)
float = number:w "." number:f ~number("#{w}.#{f}".to_f)

true = "true" ~bool_true()
false = "false" ~bool_false()

keyword = "end" | "else"

word = !keyword < /[a-zA-Z_][a-zA-Z0-9_]*/ > { text }

identifier = word:w ~ident(w)

many_expr = comment:e many_expr:m { [e] + m }
          | expr:e expr_end many_expr:m { [e] + m }
          | expr:e { [e] }

sequence = many_expr:e
           { e.size > 1 ? seq(e) : e.first }

expr_list_b = expr:e br-sp "," br-sp expr_list_b:l { [e] + l }
            | expr:e { [e] }

expr_list = br-sp expr_list_b:b br-sp { b }

if = "if" sp expr:c expr_end sequence:t expr_end "end"
     ~if_node(c,t,nil)
   | "if" sp expr:c expr_end expr:t expr_end "else" expr_end expr:f expr_end "end"
     ~if_node(c,t,f)

typed_ident = word:i ":" word:t ~typed_ident(i,t)
            | identifier

ident_list = typed_ident:i br-sp "," br-sp ident_list:l { [i] + l }
           | typed_ident:i { [i] }

def_args = "(" br-sp ident_list:l br-sp ")" { l }

ret_type = - ":" - word:t { t }

templated_name = word:w "[" expr_list:e "]" ~templated_name(w,e)
               | word:w

def_start = "def" sp templated_name:w { w }

def = def_start:w def_args?:a ret_type?:t expr_end "end"
      ~method_def(w,a,nil,t)
    | def_start:w def_args?:a ret_type?:t expr_end sequence:s expr_end "end"
      ~method_def(w,a,s,t)

class_start = "class" sp templated_name:w { w }
class_superclass = - "<" - templated_name:s { s }

class = class_start:w class_superclass?:s expr_end "end"
        ~class_def(w,s,nil)
      | class_start:w class_superclass?:s expr_end sequence:e expr_end "end"
        ~class_def(w,s,e)

operator_chars = /[~`!@#$\%^\&*\\+\-\/?:<=>\|]/
unary_operator = < operator_chars > { text }
binary_operator = < operator_chars+ > { text }

literal = float
        | integer
        | true
        | false
        | identifier

embed_rhs = literal:r "." word:w ~call(r,w)
          | literal

call_np_list = method_np_arg:e - "," br-sp call_np_list:l { [e] + l }
             | method_np_arg:e { [e] }

method_call_np = method_np_recv:r "." word:w sp call_np_list:l ~call(r,w,l)

method_np_recv = method_np_recv:r "." word:w "(" expr_list:l ")" ~call(r,w,l)
               | method_np_recv:r "[" expr_list:l "]" ~bracket(r,l)
               | literal

method_np_arg = grouped
              | binary_send
              | method_np_arg:r "." word:w "(" expr_list?:l ")" ~call(r,w,l)
              | method_np_arg:r "." word:w ~call(r,w,nil)
              | method_np_arg:r "[" expr_list:l "]" ~bracket(r,l)
              | literal

method_call = method_call:r "." word:w "(" expr_list?:l ")" ~call(r,w,l)
            | method_call:r "." word:w ~call(r,w,nil)
            | method_call:r "[" expr_list:l "]" ~bracket(r,l)
            | literal

bin_expr = bin_expr:r "." word:w "(" expr_list?:l ")" ~call(r,w,l)
          | bin_expr:r "." word:w ~call(r,w,nil)
          | literal

binary_c = (- binary_operator:o br-sp bin_expr:e { [o, e] })+:bs { bs.flatten }
binary_send = bin_expr:l binary_c:c { resolve(nil, l, c).first }

call = unary_operator:o expr:r ~unary(r,o)
     | binary_send
     | method_call_np
     | method_call

expr = if
     | def
     | class
     | call

grouped = "(" expr:e ")" ~group(e)

root = sequence:e eof { @ast = e }
